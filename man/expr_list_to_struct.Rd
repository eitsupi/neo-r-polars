% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr-list.R
\name{expr_list_to_struct}
\alias{expr_list_to_struct}
\title{Convert the Series of type List to a Series of type Struct}
\usage{
expr_list_to_struct(
  n_field_strategy = c("first_non_null", "max_width"),
  fields = NULL,
  upper_bound = NULL
)
}
\arguments{
\item{n_field_strategy}{One of \code{"first_non_null"} or \code{"max_width"}.
Strategy to determine the number of fields of the struct.
\itemize{
\item \code{"first_non_null"} (default): Set number of fields equal to
the length of the first non zero-length sublist.
\item \code{"max_width"}: Set number of fields as max length of all sublists.
}

If the \code{field} argument is character, this argument will be ignored.}

\item{fields}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}
\code{NULL} (default) or character vector of field names, or a function that
takes an integer index and returns character.
If the name and number of the desired fields is known in advance,
character vector of field names can be given, which will be assigned by index.
Otherwise, to dynamically assign field names, a custom function can be used;
if neither are set, fields will be \code{field_0}, \code{field_1}...
See the examples for details.}

\item{upper_bound}{Single positive integer value or \code{NULL} (default).
A \link{LazyFrame} needs to know the schema at all times,
so the caller must provide an upper bound of the number of struct fields
that will be created; if set incorrectly, subsequent operations may fail.
When operating on a DataFrame, the schema does not need to be tracked
or pre-determined, as the result will be eagerly evaluated,
so this argument can be \code{NULL}.
If the \code{fields} argument is character, this argument will be ignored.}
}
\value{
A polars \link{expression}
}
\description{
Convert the Series of type List to a Series of type Struct
}
\details{
It is recommended to set \code{upper_bound} to the correct output size
of the struct. If this is not set, Polars will not know the output type of
this operation and will set it to \code{Unknown} which can lead to errors because
Polars is not able to resolve the query.

For performance reasons, the length of the first non-null sublist is used to
determine the number of output fields by default.
If the sublists can be of different lengths then \code{n_field_strategy="max_width"}
must be used to obtain the expected result.
}
\examples{
df <- pl$DataFrame(n = list(c(0, 1), c(0, 1, 2)))

# Convert list to struct with default field name assignment:

# This will become a struct with 2 fields.
df$select(pl$col("n")$list$to_struct())$unnest("n")

# As the shorter sublist comes first,
# we must use the max_width strategy to force a search for the longest.
# This will become a struct with 3 fields.
df$select(
  pl$col("n")$list$to_struct(n_field_strategy = "max_width")
)$unnest("n")

# Convert list to struct with field name assignment by
# function/index:
df$select(
  pl$col("n")$list$to_struct(
    fields = \(idx) paste0("n", idx + 1),
    n_field_strategy = "max_width"
  )
)$unnest("n")

# Convert list to struct with field name assignment by
# index from a list of names:
df$select(pl$col("n")$list$to_struct(
  fields = c("one", "two", "three"))
)$unnest("n")
}
