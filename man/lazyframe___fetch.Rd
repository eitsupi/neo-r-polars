% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazyframe-frame.R
\name{lazyframe___fetch}
\alias{lazyframe___fetch}
\title{Collect a small number of rows for debugging purposes}
\usage{
lazyframe___fetch(
  n_rows = 500,
  ...,
  type_coercion = TRUE,
  `_type_check` = TRUE,
  predicate_pushdown = TRUE,
  projection_pushdown = TRUE,
  simplify_expression = TRUE,
  no_optimization = FALSE,
  slice_pushdown = TRUE,
  comm_subplan_elim = TRUE,
  comm_subexpr_elim = TRUE,
  cluster_with_columns = TRUE,
  collapse_joins = TRUE,
  `_check_order` = TRUE
)
}
\arguments{
\item{n_rows}{Scalar integer-ish indicating the number of rows to collect from the data source.}

\item{...}{These dots are for future extensions and must be empty.}

\item{type_coercion}{A logical, indicates type coercion optimization.}

\item{predicate_pushdown}{A logical, indicates predicate pushdown optimization.}

\item{projection_pushdown}{A logical, indicates projection pushdown optimization.}

\item{simplify_expression}{A logical, indicates simplify expression optimization.}

\item{no_optimization}{A logical. If \code{TRUE}, turn off (certain) optimizations.}

\item{slice_pushdown}{A logical, indicates slice pushdown optimization.}

\item{comm_subplan_elim}{A logical, indicates trying to cache branching subplans that occur
on self-joins or unions.}

\item{comm_subexpr_elim}{A logical, indicates trying to cache common subexpressions.}

\item{cluster_with_columns}{A logical, indicates to combine sequential independent calls
to with_columns.}

\item{collapse_joins}{Collapse a join and filters into a faster join.}

\item{_check_order, _type_check}{For internal use only.}
}
\value{
A polars \link{DataFrame}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}
This is strictly a utility function that can help to debug queries using a
smaller number of rows, and should \emph{not} be used in production code.
}
\details{
This is similar to a \code{\link[=lazyframe__collect]{<lazyframe>$collect()}} operation,
but it overwrites the number of rows read by \emph{every} scan operation.
Be aware that \code{fetch} does not guarantee the final number of rows in the DataFrame.
Filters, join operations and fewer rows being available in the scanned data
will all influence the final number of rows
(joins are especially susceptible to this, and may return no data at all
if \code{n_rows} is too small as the join keys may not be present).
}
\keyword{internal}
