% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataframe-frame.R
\name{dataframe__join}
\alias{dataframe__join}
\title{Join DataFrames}
\usage{
dataframe__join(
  other,
  on = NULL,
  how = c("inner", "full", "left", "right", "semi", "anti", "cross"),
  ...,
  left_on = NULL,
  right_on = NULL,
  suffix = "_right",
  validate = c("m:m", "1:m", "m:1", "1:1"),
  nulls_equal = FALSE,
  coalesce = NULL,
  maintain_order = c("none", "left", "right", "left_right", "right_left"),
  allow_parallel = TRUE,
  force_parallel = FALSE
)
}
\arguments{
\item{other}{DataFrame to join with.}

\item{on}{Either a vector of column names or a list of expressions and/or
strings. Use \code{left_on} and \code{right_on} if the column names to match on are
different between the two DataFrames.}

\item{how}{One of the following methods:
\itemize{
\item "inner": returns rows that have matching values in both tables
\item "left": returns all rows from the left table, and the matched rows from
the right table
\item "right": returns all rows from the right table, and the matched rows from
the left table
\item "full": returns all rows when there is a match in either left or right
table
\item "cross": returns the Cartesian product of rows from both tables
\item "semi": returns rows from the left table that have a match in the right
table.
\item "anti": returns rows from the left table that have no match in the right
table.
}}

\item{...}{These dots are for future extensions and must be empty.}

\item{left_on, right_on}{Same as \code{on} but only for the left or the right
DataFrame. They must have the same length.}

\item{suffix}{Suffix to add to duplicated column names.}

\item{validate}{Checks if join is of specified type:
\itemize{
\item \code{"m:m"} (default): many-to-many, doesn't perform any checks;
\item \code{"1:1"}: one-to-one, check if join keys are unique in both left and right
datasets;
\item \code{"1:m"}: one-to-many, check if join keys are unique in left dataset
\item \code{"m:1"}: many-to-one, check if join keys are unique in right dataset
}

Note that this is currently not supported by the streaming engine.}

\item{nulls_equal}{Join on null values. By default null values will never
produce matches.}

\item{coalesce}{Coalescing behavior (merging of join columns).
\itemize{
\item \code{NULL}: join specific.
\item \code{TRUE}: Always coalesce join columns.
\item \code{FALSE}: Never coalesce join columns.
Note that joining on any other expressions than \code{col} will turn off
coalescing.
}}

\item{maintain_order}{Which frame row order to preserve, if any. Do not rely
on any observed ordering without explicitly setting this parameter, as your
code may break in a future release. Not specifying any ordering can improve
performance. Supported for inner, left, right and full joins.
\itemize{
\item \code{"none"}: No specific ordering is desired. The ordering might differ
across Polars versions or even between different runs.
\item \code{"left"}: Preserves the order of the left frame.
\item \code{"right"}: Preserves the order of the right frame.
\item \code{"left_right"}: First preserves the order of the left frame, then the
right.
\item \code{"right_left"}: First preserves the order of the right frame, then the
left.
}}

\item{allow_parallel}{Allow the physical plan to optionally evaluate the
computation of both DataFrames up to the join in parallel.}

\item{force_parallel}{Force the physical plan to evaluate the computation of
both DataFrames up to the join in parallel.}
}
\value{
A polars \link{DataFrame}
}
\description{
This function can do both mutating joins (adding columns based on matching
observations, for example with \code{how = "left"}) and filtering joins (keeping
observations based on matching observations, for example with \code{how = "inner"}).
}
\examples{
df <- pl$DataFrame(
  foo = 1:3,
  bar = c(6, 7, 8),
  ham = c("a", "b", "c")
)
other_df <- pl$DataFrame(
  apple = c("x", "y", "z"),
  ham = c("a", "b", "d")
)
df$join(other_df, on = "ham")

df$join(other_df, on = "ham", how = "full")

df$join(other_df, on = "ham", how = "left", coalesce = TRUE)

df$join(other_df, on = "ham", how = "semi")

df$join(other_df, on = "ham", how = "anti")
}
