% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr-expr.R
\name{expr__rolling_median}
\alias{expr__rolling_median}
\title{Apply a rolling median over values}
\usage{
expr__rolling_median(
  window_size,
  weights = NULL,
  ...,
  min_samples = NULL,
  center = FALSE
)
}
\arguments{
\item{window_size}{The length of the window in number of elements.}

\item{weights}{An optional slice with the same length as the window that
will be multiplied elementwise with the values in the window.}

\item{...}{These dots are for future extensions and must be empty.}

\item{min_samples}{The number of values in the window that should be
non-null before computing a result. If \code{NULL} (default), it will be set
equal to \code{window_size}.}

\item{center}{If \code{TRUE}, set the labels at the center of the window.}
}
\value{
A polars \link{expression}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

A window of length \code{window_size} will traverse the array. The values that
fill this window will (optionally) be multiplied with the weights given by
the \code{weights} vector. The resulting values will be aggregated.

The window at a given row will include the row itself, and the
\code{window_size - 1} elements before it.
}
\details{
If you want to compute multiple aggregation statistics over the same dynamic
window, consider using \code{\link[=expr__rolling]{$rolling()}} - this method can cache
the window size computation.
}
\examples{
df <- pl$DataFrame(a = 1:6)
df$with_columns(
  rolling_median = pl$col("a")$rolling_median(window_size = 2)
)

# Specify weights to multiply the values in the window with:
df$with_columns(
  rolling_median = pl$col("a")$rolling_median(
    window_size = 2, weights = c(0.25, 0.75)
  )
)

# Center the values in the window
df$with_columns(
  rolling_median = pl$col("a")$rolling_median(window_size = 3, center = TRUE)
)
}
