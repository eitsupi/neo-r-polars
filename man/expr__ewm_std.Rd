% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr-expr.R
\name{expr__ewm_std}
\alias{expr__ewm_std}
\title{Compute exponentially-weighted moving standard deviation}
\usage{
expr__ewm_std(
  ...,
  com,
  span,
  half_life,
  alpha,
  adjust = TRUE,
  bias = FALSE,
  min_periods = 1,
  ignore_nulls = FALSE
)
}
\arguments{
\item{...}{These dots are for future extensions and must be empty.}

\item{com}{Specify decay in terms of center of mass, \eqn{\gamma}, with
\deqn{\alpha = \frac{1}{1 + \gamma} \; \forall \; \gamma \geq 0}.}

\item{span}{Specify decay in terms of span, \eqn{\theta}, with
\deqn{\alpha = \frac{2}{\theta + 1} \; \forall \; \theta \geq 1}}

\item{half_life}{Specify decay in terms of half-life, \eqn{\lambda}, with
\deqn{\alpha = 1 - \exp \left\{ \frac{ -\ln(2) }{ \lambda } \right\} \;
\forall \; \lambda > 0}}

\item{alpha}{Specify smoothing factor alpha directly, \eqn{0 < \alpha
\leq 1}.}

\item{adjust}{Divide by decaying adjustment factor in beginning periods to
account for imbalance in relative weightings:
\itemize{
\item when \code{TRUE} (default), the EW function is calculated using weights
\eqn{w_i = (1 - \alpha)^i};
\item when \code{FALSE}, the EW function is calculated recursively by \deqn{y_0 = x_0
 ; y_t = (1 - \alpha)y_{t - 1} + \alpha x_t}
}}

\item{bias}{If \code{FALSE} (default), apply a correction to make the estimate
statistically unbiased.}

\item{min_periods}{The number of values in the window that should be
non-null before computing a result. If \code{NULL} (default), it will be set
equal to \code{window_size}.}

\item{ignore_nulls}{Ignore missing values when calculating weights.
\itemize{
\item when \code{FALSE} (default), weights are based on absolute positions. For
example, the weights of \eqn{x_0} and \eqn{x_2} used in calculating the
final weighted average of (\eqn{x_0}, null, \eqn{x_2}) are
\eqn{(1-\alpha)^2} and \eqn{1} if \code{adjust = TRUE}, and \eqn{(1-\alpha)^2}
and \eqn{\alpha} if \code{adjust = FALSE}.
\item when \code{TRUE}, weights are based on relative positions. For example, the
weights of \eqn{x_0} and \eqn{x_2} used in calculating the final weighted
average of (\eqn{x_0}, null, \eqn{x_2}) are \eqn{1-\alpha} and \eqn{1} if
\code{adjust = TRUE}, and \eqn{1-\alpha} and \eqn{\alpha} if \code{adjust = FALSE}.
}}
}
\value{
A polars \link{expression}
}
\description{
The \code{\link[=as_polars_expr]{as_polars_expr()}} function creates a polars \link{expression} from various R objects.
This function is used internally by various polars functions that accept \link[=Expr]{expressions}.
In most cases, users should use \code{\link[=pl__lit]{pl$lit()}} instead of this function, which is
a shorthand for \code{as_polars_expr(x, as_lit = TRUE)}.
(In other words, this function can be considered as an internal implementation to realize
the \code{lit} function of the Polars API in other languages.)
}
\details{
Because R objects are typically mapped to \link{Series}, this function often calls \code{\link[=as_polars_series]{as_polars_series()}} internally.
However, unlike R, Polars has scalars of length 1, so if an R object is converted to a \link{Series} of length 1,
this function get the first value of the Series and convert it to a scalar literal.
If you want to implement your own conversion from an R class to a Polars object,
define an S3 method for \code{\link[=as_polars_series]{as_polars_series()}} instead of this function.
\subsection{Default S3 method}{

Create a \link{Series} by calling \code{\link[=as_polars_series]{as_polars_series()}} and then convert that \link{Series} to an \link{Expr}.
If the length of the \link{Series} is \code{1}, it will be converted to a scalar value.

Additional arguments \code{...} are passed to \code{\link[=as_polars_series]{as_polars_series()}}.
}

\subsection{S3 method for \link{character}}{

If the \code{as_lit} argument is \code{FALSE} (default), this function will call \code{\link[=pl__col]{pl$col()}} and
the character vector is treated as column names.
}
}
\section{Literal scalar mapping}{
Since R has no scalar class, each of the following types of length 1 cases is specially
converted to a scalar literal.
\itemize{
\item character: String
\item logical: Boolean
\item integer: Int32
\item double: Float64
}

These types' \code{NA} is converted to a \code{null} literal with casting to the corresponding Polars type.

The \link{raw} type vector is converted to a Binary scalar.
\itemize{
\item raw: Binary
}

\code{NULL} is converted to a Null type \code{null} literal.
\itemize{
\item NULL: Null
}

For other R class, the default S3 method is called and R object will be converted via
\code{\link[=as_polars_series]{as_polars_series()}}. So the type mapping is defined by \code{\link[=as_polars_series]{as_polars_series()}}.
}

\examples{
df <- pl$DataFrame(a = 1:3)
df$select(pl$col("a")$ewm_std(com = 1, ignore_nulls = FALSE))
}
\seealso{
\itemize{
\item \code{\link[=as_polars_series]{as_polars_series()}}: R -> Polars type mapping is mostly defined by this function.
}
}
