% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr-expr.R
\name{expr__map_batches}
\alias{expr__map_batches}
\title{Apply a custom R function to a whole Series or sequence of Series.}
\usage{
expr__map_batches(lambda, return_dtype = NULL, ...)
}
\arguments{
\item{lambda}{Function to apply.}

\item{return_dtype}{Dtype of the output Series. If \code{NULL} (default), the
dtype will be inferred based on the first non-null value that is returned by
the function. This can lead to unexpected results, so it is recommended to
provide the return dtype.}

\item{...}{These dots are for future extensions and must be empty.}
}
\value{
A polars \link{expression}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

The output of this custom function is presumed to be either a Series, or a
scalar that will be converted into a Series. If the result is a scalar and
you want it to stay as a scalar, pass in \code{returns_scalar = TRUE}.

If you want to apply a custom function elementwise over single values, see
map_elements(). A reasonable use case for map
functions is transforming the values represented by an expression using a
third-party package.
}
\examples{
df <- pl$DataFrame(
  sine = c(0.0, 1.0, 0.0, -1.0),
  cosine = c(1.0, 0.0, -1.0, 0.0)
)
df$select(pl$all()$map_batches(\(x) {
  elems <- as.vector(x)
  which.max(elems)
}))


# Call a function that takes multiple arguments by creating a struct and
# referencing its fields inside the function call.
df <- pl$DataFrame(
  a = c(5, 1, 0, 3),
  b = c(4, 2, 3, 4),
)
df$with_columns(
  a_times_b = pl$struct("a", "b")$map_batches(
    \(x) x$struct$field("a") * x$struct$field("b")
  )
)
}
