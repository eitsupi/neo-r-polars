% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr-expr.R
\name{expr__map_batches}
\alias{expr__map_batches}
\title{Apply a custom R function to a whole Series or sequence of Series.}
\usage{
expr__map_batches(
  f,
  return_dtype = NULL,
  ...,
  agg_list = FALSE,
  is_elementwise = FALSE,
  returns_scalar = FALSE
)
}
\arguments{
\item{f}{Function to apply.}

\item{return_dtype}{Dtype of the output Series. If \code{NULL} (default), the
dtype will be inferred based on the first non-null value that is returned by
the function. This can lead to unexpected results, so it is recommended to
provide the return dtype.}

\item{...}{These dots are for future extensions and must be empty.}

\item{agg_list}{Aggregate the values of the expression into a list before
applying the function. This parameter only works in a group-by context. The
function will be invoked only once on a list of groups, rather than once per
group.}

\item{is_elementwise}{If \code{TRUE}, this can run in the streaming engine, but
may yield incorrect results in group-by. Ensure you know what you are doing!}

\item{returns_scalar}{If the function returns a scalar, by default it will
be wrapped in a list in the output, since the assumption is that the
function always returns something Series-like. If you want to keep the
result as a scalar, set this argument to \code{TRUE}.}
}
\value{
A polars \link{expression}
}
\description{
The output of this custom function is presumed to be either a Series, or a
scalar that will be converted into a Series. If the result is a scalar and
you want it to stay as a scalar, pass in \code{returns_scalar = TRUE}.

If you want to apply a custom function elementwise over single values, see
\link[=expr__map_elements]{map_elements()}. A reasonable use case for map
functions is transforming the values represented by an expression using a
third-party package.
}
\examples{
df <- pl$DataFrame(
  sine = c(0.0, 1.0, 0.0, -1.0),
  cosine = c(1.0, 0.0, -1.0, 0.0)
)
df$select(pl$all()$map_batches(\(x) {
  elems <- as.vector(x)
  which.max(elems)
}))

# In a group-by context, the `agg_list` parameter can improve performance if
# used correctly. The following example has `agg_list = FALSE`, which causes
# the function to be applied once per group. The input of the function is a
# Series of type Int64. This is less efficient.
df <- pl$DataFrame(
  a = c(0, 1, 0, 1),
  b = c(1, 2, 3, 4)
)
system.time({
  print(
    df$group_by("a")$agg(
      pl$col("b")$map_batches(\(x) x + 2, agg_list = FALSE)
    )
  )
})

# Using `agg_list = TRUE` would be more efficient. In this example, the input
# of the function is a Series of type List(Int64).
system.time({
  print(
    df$group_by("a")$agg(
      pl$col("b")$map_batches(
        \(x) x$list$eval(pl$element() + 2),
        agg_list = TRUE
      )
    )
  )
})

# Hereâ€™s an example of a function that returns a scalar, where we want it to
# stay as a scalar:
df <- pl$DataFrame(
  a = c(0, 1, 0, 1),
  b = c(1, 2, 3, 4),
)
df$group_by("a")$agg(
  pl$col("b")$map_batches(\(x) x$max(), returns_scalar = TRUE)
)

# Call a function that takes multiple arguments by creating a struct and
# referencing its fields inside the function call.
df <- pl$DataFrame(
  a = c(5, 1, 0, 3),
  b = c(4, 2, 3, 4),
)
df$with_columns(
  a_times_b = pl$struct("a", "b")$map_batches(
    \(x) x$struct$field("a") * x$struct$field("b")
  )
)
}
