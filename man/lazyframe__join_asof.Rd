% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazyframe-frame.R
\name{lazyframe__join_asof}
\alias{lazyframe__join_asof}
\title{Perform joins on nearest keys}
\usage{
lazyframe__join_asof(
  other,
  ...,
  left_on = NULL,
  right_on = NULL,
  on = NULL,
  by_left = NULL,
  by_right = NULL,
  by = NULL,
  strategy = c("backward", "forward", "nearest"),
  suffix = "_right",
  tolerance = NULL,
  allow_parallel = TRUE,
  force_parallel = FALSE,
  coalesce = TRUE,
  allow_exact_matches = TRUE,
  check_sortedness = TRUE
)
}
\arguments{
\item{other}{LazyFrame to join with.}

\item{...}{These dots are for future extensions and must be empty.}

\item{by_left, by_right}{Same as \code{by} but only for the left or the right
table. They must have the same length.}

\item{by}{Join on these columns before performing asof join. Either a vector
of column names or a list of expressions and/or strings. Use \code{left_by} and
\code{right_by} if the column names to match on are different between the two
tables.}

\item{strategy}{Strategy for where to find match:
\itemize{
\item \code{"backward"} (default): search for the last row in the right table whose
\code{on} key is less than or equal to the left key.
\item \code{"forward"}: search for the first row in the right table whose \code{on} key is
greater than or equal to the left key.
\item \code{"nearest"}: search for the last row in the right table whose value is
nearest to the left key. String keys are not currently supported for a
nearest search.
}}

\item{tolerance}{Numeric tolerance. By setting this the join will only be
done if the near keys are within this distance. If an asof join is done on
columns of dtype "Date", "Datetime", "Duration" or "Time", use the Polars
duration string language (see details).}

\item{coalesce}{Coalescing behavior (merging of \code{on} / \code{left_on} /
\code{right_on} columns):
\itemize{
\item \code{TRUE}: Always coalesce join columns;
\item \code{FALSE}: Never coalesce join columns.
Note that joining on any other expressions than \code{col} will turn off
coalescing.
}}

\item{allow_exact_matches}{Whether exact matches are valid join predicates.
If \code{TRUE} (default), allow matching with the same on value (i.e.
less-than-or-equal-to / greater-than-or-equal-to). Otherwise, don’t match
the same on value (i.e., strictly less-than / strictly greater-than).}

\item{check_sortedness}{Check the sortedness of the asof keys. If the keys
are not sorted, polars will error, or raise a warning if the \code{by} argument
is provided. This might become a hard error in the future.}
}
\description{
This is similar to a left-join except that we match on nearest key rather
than equal keys. Both frames must be sorted by the \code{asof_join} key.
}
\section{Polars duration string language}{

Polars duration string language is a simple representation of
durations. It is used in many Polars functions that accept durations.

It has the following format:
\itemize{
\item 1ns (1 nanosecond)
\item 1us (1 microsecond)
\item 1ms (1 millisecond)
\item 1s (1 second)
\item 1m (1 minute)
\item 1h (1 hour)
\item 1d (1 calendar day)
\item 1w (1 calendar week)
\item 1mo (1 calendar month)
\item 1q (1 calendar quarter)
\item 1y (1 calendar year)
}

Or combine them: \code{"3d12h4m25s"} # 3 days, 12 hours, 4 minutes, and 25 seconds

By "calendar day", we mean the corresponding time on the next day
(which may not be 24 hours, due to daylight savings).
Similarly for "calendar week", "calendar month", "calendar quarter", and "calendar year".
}

\examples{
gdp <- pl$LazyFrame(
  date = as.Date(c("2016-1-1", "2017-5-1", "2018-1-1", "2019-1-1", "2020-1-1")),
  gdp = c(4164, 4411, 4566, 4696, 4827)
)

pop <- pl$LazyFrame(
  date = as.Date(c("2016-3-1", "2018-8-1", "2019-1-1")),
  population = c(82.19, 82.66, 83.12)
)

# optional make sure tables are already sorted with "on" join-key
gdp <- gdp$sort("date")
pop <- pop$sort("date")


# Note how the dates don’t quite match. If we join them using join_asof and
# strategy = 'backward', then each date from population which doesn’t have
# an exact match is matched with the closest earlier date from gdp:
pop$join_asof(gdp, on = "date", strategy = "backward")$collect()

# Note how:
# - date 2016-03-01 from population is matched with 2016-01-01 from gdp;
# - date 2018-08-01 from population is matched with 2018-01-01 from gdp.
# You can verify this by passing coalesce = FALSE:
pop$join_asof(
  gdp,
  on = "date", strategy = "backward", coalesce = FALSE
)$collect()

# If we instead use strategy = 'forward', then each date from population
# which doesn’t have an exact match is matched with the closest later date
# from gdp:
pop$join_asof(gdp, on = "date", strategy = "forward")$collect()

# Note how:
# - date 2016-03-01 from population is matched with 2017-01-01 from gdp;
# - date 2018-08-01 from population is matched with 2019-01-01 from gdp.

# Finally, strategy = 'nearest' gives us a mix of the two results above, as
# each date from population which doesn’t have an exact match is matched
# with the closest date from gdp, regardless of whether it’s earlier or
# later:
pop$join_asof(gdp, on = "date", strategy = "nearest")$collect()

# Note how:
# - date 2016-03-01 from population is matched with 2016-01-01 from gdp;
# - date 2018-08-01 from population is matched with 2019-01-01 from gdp.

# The `by` argument allows joining on another column first, before the asof
# join. In this example we join by country first, then asof join by date, as
# above.
gdp2 <- pl$LazyFrame(
  country = rep(c("Germany", "Netherlands"), each = 5),
  date = rep(
    as.Date(c("2016-1-1", "2017-1-1", "2018-1-1", "2019-1-1", "2020-1-1")),
    2
  ),
  gdp = c(4164, 4411, 4566, 4696, 4827, 784, 833, 914, 910, 909)
)$sort("country", "date")
gdp2$collect()

pop2 <- pl$LazyFrame(
  country = rep(c("Germany", "Netherlands"), each = 3),
  date = rep(as.Date(c("2016-3-1", "2018-8-1", "2019-1-1")), 2),
  population = c(82.19, 82.66, 83.12, 17.11, 17.32, 17.40)
)$sort("country", "date")
pop2$collect()

pop2$join_asof(
  gdp2,
  by = "country", on = "date", strategy = "nearest"
)$collect()
}
