% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazyframe-frame.R
\name{lazyframe__join}
\alias{lazyframe__join}
\title{Join LazyFrames}
\usage{
lazyframe__join(
  other,
  on = NULL,
  how = "inner",
  ...,
  left_on = NULL,
  right_on = NULL,
  suffix = "_right",
  validate = "m:m",
  join_nulls = FALSE,
  allow_parallel = TRUE,
  force_parallel = FALSE,
  coalesce = NULL
)
}
\arguments{
\item{other}{LazyFrame to join with.}

\item{on}{Either a vector of column names or a list of expressions and/or
strings. Use \code{left_on} and \code{right_on} if the column names to match on are
different between the two DataFrames.}

\item{how}{One of the following methods:
\itemize{
\item "inner": returns rows that have matching values in both tables
\item "left": returns all rows from the left table, and the matched rows from
the right table
\item "right": returns all rows from the right table, and the matched rows from
the left table
\item "full": returns all rows when there is a match in either left or right
table
\item "cross": returns the Cartesian product of rows from both tables
\item "semi": returns rows from the left table that have a match in the right
table.
\item "anti": returns rows from the left table that have no match in the right
table.
}}

\item{...}{These dots are for future extensions and must be empty.}

\item{left_on, right_on}{Same as \code{on} but only for the left or the right
DataFrame. They must have the same length.}

\item{suffix}{Suffix to add to duplicated column names.}

\item{validate}{Checks if join is of specified type:
\itemize{
\item \code{"m:m"} (default): many-to-many, doesn't perform any checks;
\item \code{"1:1"}: one-to-one, check if join keys are unique in both left and right
datasets;
\item \code{"1:m"}: one-to-many, check if join keys are unique in left dataset
\item \code{"m:1"}: many-to-one, check if join keys are unique in right dataset
}

Note that this is currently not supported by the streaming engine.}

\item{join_nulls}{Join on null values. By default null values will never
produce matches.}

\item{allow_parallel}{Allow the physical plan to optionally evaluate the
computation of both DataFrames up to the join in parallel.}

\item{force_parallel}{Force the physical plan to evaluate the computation of
both DataFrames up to the join in parallel.}

\item{coalesce}{Coalescing behavior (merging of join columns).
\itemize{
\item \code{NULL}: join specific.
\item \code{TRUE}: Always coalesce join columns.
\item \code{FALSE}: Never coalesce join columns.
Note that joining on any other expressions than \code{col} will turn off
coalescing.
}}
}
\value{
A polars \link{LazyFrame}
}
\description{
This function can do both mutating joins (adding columns based on matching
observations, for example with \code{how = "left"}) and filtering joins (keeping
observations based on matching observations, for example with \code{how = "inner"}).
}
\examples{
lf <- pl$LazyFrame(
  foo = 1:3,
  bar = c(6, 7, 8),
  ham = c("a", "b", "c")
)
other_lf <- pl$LazyFrame(
  apple = c("x", "y", "z"),
  ham = c("a", "b", "d")
)
lf$join(other_lf, on = "ham")$collect()

lf$join(other_lf, on = "ham", how = "full")$collect()

lf$join(other_lf, on = "ham", how = "left", coalesce = TRUE)$collect()

lf$join(other_lf, on = "ham", how = "semi")$collect()

lf$join(other_lf, on = "ham", how = "anti")$collect()
}
