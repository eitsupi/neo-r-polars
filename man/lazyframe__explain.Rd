% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lazyframe-frame.R
\name{lazyframe__explain}
\alias{lazyframe__explain}
\title{Create a string representation of the query plan}
\usage{
lazyframe__explain(
  ...,
  format = c("plain", "tree"),
  optimized = TRUE,
  type_coercion = TRUE,
  `_type_check` = TRUE,
  predicate_pushdown = TRUE,
  projection_pushdown = TRUE,
  simplify_expression = TRUE,
  slice_pushdown = TRUE,
  comm_subplan_elim = TRUE,
  comm_subexpr_elim = TRUE,
  cluster_with_columns = TRUE,
  collapse_joins = TRUE,
  streaming = FALSE,
  `_check_order` = TRUE
)
}
\arguments{
\item{...}{These dots are for future extensions and must be empty.}

\item{format}{The format to use for displaying the logical plan. Must be
either \code{"plain"} (default) or \code{"tree"}.}

\item{optimized}{Return an optimized query plan. If \code{TRUE} (default), the
subsequent optimization flags control which optimizations run.}

\item{type_coercion}{A logical, indicats type coercion optimization.}

\item{predicate_pushdown}{A logical, indicats predicate pushdown optimization.}

\item{projection_pushdown}{A logical, indicats projection pushdown optimization.}

\item{simplify_expression}{A logical, indicats simplify expression optimization.}

\item{slice_pushdown}{A logical, indicats slice pushdown optimization.}

\item{comm_subplan_elim}{A logical, indicats tring to cache branching subplans that occur
on self-joins or unions.}

\item{comm_subexpr_elim}{A logical, indicats tring to cache common subexpressions.}

\item{cluster_with_columns}{A logical, indicats to combine sequential independent calls
to with_columns.}

\item{collapse_joins}{Collapse a join and filters into a faster join.}

\item{streaming}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}
A logical. If \code{TRUE}, process the query in batches to handle larger-than-memory data.
If \code{FALSE} (default), the entire query is processed in a single batch.
Note that streaming mode is considered unstable.
It may be changed at any point without it being considered a breaking change.}

\item{_check_order, _type_check}{For internal use only.}
}
\value{
A character value containing the query plan.
}
\description{
The query plan is read from bottom to top. When \code{optimized = FALSE}, the
query as it was written by the user is shown. This is not what Polars runs.
Instead, it applies optimizations that are displayed by default by \verb{$explain()}.
One classic example is the predicate pushdown, which applies the filter as
early as possible (i.e. at the bottom of the plan).
}
\examples{
lazy_frame <- as_polars_lf(iris)

# Prepare your query
lazy_query <- lazy_frame$sort("Species")$filter(pl$col("Species") != "setosa")

# This is the query that was written by the user, without any optimizations
# (use cat() for better printing)
lazy_query$explain(optimized = FALSE) |> cat()

# This is the query after `polars` optimizes it: instead of sorting first and
# then filtering, it is faster to filter first and then sort the rest.
lazy_query$explain() |> cat()

# Also possible to see this as tree format
lazy_query$explain(format = "tree") |> cat()
}
