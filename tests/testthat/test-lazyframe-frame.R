test_that("select works lazy/eager", {
  .data <- pl$DataFrame(
    int32 = 1:5,
    int64 = as_polars_series(1:5)$cast(pl$Int64),
    string = letters[1:5],
  )

  expect_query_equal(
    .input$select("int32"),
    .data,
    pl$DataFrame(int32 = 1:5)
  )
  expect_query_equal(
    .input$select(pl$lit("int32")),
    .data,
    pl$DataFrame(literal = "int32")
  )
  expect_query_equal(
    .input$select(foo = "int32"),
    .data,
    pl$DataFrame(foo = 1:5)
  )
})

test_that("POLARS_AUTO_STRUCTIFY works for select", {
  .data <- pl$DataFrame(
    foo = 1:3,
    bar = 6:8,
    ham = letters[1:3],
  )

  withr::with_envvar(
    c(POLARS_AUTO_STRUCTIFY = "foo"),
    {
      expect_query_error(
        .input$select(1),
        .data,
        r"(Environment variable `POLARS_AUTO_STRUCTIFY` must be one of \('0', '1'\), got 'foo')"
      )
    }
  )

  withr::with_envvar(
    c(POLARS_AUTO_STRUCTIFY = "0"),
    {
      expect_query_error(
        .input$select(is_odd = ((pl$col(pl$Int32) %% 2) == 1)$name$suffix("_is_odd")),
        .data,
        "`keep`, `suffix`, `prefix` should be last expression"
      )

      expect_query_equal(
        withr::with_envvar(c(POLARS_AUTO_STRUCTIFY = "1"), {
          .input$select(is_odd = ((pl$col(pl$Int32) %% 2) == 1)$name$suffix("_is_odd"))
        }),
        .data,
        as_polars_lf(.data)$select(
          is_odd = pl$struct(((pl$col(pl$Int32) %% 2) == 1)$name$suffix("_is_odd")),
        )$collect()
      )
    }
  )
})

test_that("slice/head/tail works lazy/eager", {
  .data <- pl$DataFrame(
    foo = 1:5,
    bar = 6:10,
  )

  # slice
  expect_query_equal(
    .input$slice(1),
    .data,
    pl$DataFrame(foo = 2:5, bar = 7:10)
  )
  expect_query_equal(
    .input$slice(1, 2),
    .data,
    pl$DataFrame(foo = 2:3, bar = 7:8)
  )
  expect_query_equal(
    .input$slice(1, 2),
    .data,
    pl$DataFrame(foo = 2:3, bar = 7:8)
  )
  expect_query_equal(
    .input$slice(4, 100),
    .data,
    pl$DataFrame(foo = 5L, bar = 10L)
  )
  expect_eager_equal_lazy_error(
    .input$slice(0, -2),
    .data,
    pl$DataFrame(foo = 1:3, bar = 6:8),
    r"(negative slice length \(-2\) are invalid for LazyFrame)"
  )

  # head
  expect_query_equal(
    .input$head(1),
    .data,
    pl$DataFrame(foo = 1L, bar = 6L)
  )
  expect_query_equal(
    .input$head(100),
    .data,
    .data
  )
  expect_eager_equal_lazy_error(
    .input$head(-4),
    .data,
    pl$DataFrame(foo = 1L, bar = 6L),
    r"(negative slice length \(-4\) are invalid for LazyFrame)"
  )

  # tail
  expect_query_equal(
    .input$tail(1),
    .data,
    pl$DataFrame(foo = 5L, bar = 10L)
  )
  expect_query_equal(
    .input$tail(100),
    .data,
    .data
  )
  expect_eager_equal_lazy_error(
    .input$tail(-4),
    .data,
    pl$DataFrame(foo = 5L, bar = 10L),
    r"(-4\.0 is out of range that can be safely converted to u32)"
  )
})

test_that("with_columns: basic usage", {
  df <- pl$DataFrame(x = 1:2)

  expect_query_equal(
    .input$with_columns(y = 1 + pl$col("x"), z = pl$col("x")^2),
    df,
    pl$DataFrame(x = 1:2, y = c(2, 3), z = c(1, 4))
  )

  # cannot reuse defined variable in same statement
  expect_query_error(
    .input$with_columns(y = 1 + pl$col("x"), z = pl$col("y")^2),
    df,
    "Column(s) not found: y",
    fixed = TRUE
  )

  # chaining multiple with_columns works
  expect_query_equal(
    .input$with_columns(y = 1 + pl$col("x"))$with_columns(z = pl$col("y")^2),
    df,
    pl$DataFrame(x = 1:2, y = c(2, 3), z = c(4, 9))
  )
})

test_that("with_columns can create list variables", {
  df <- pl$DataFrame(x = 1:2)

  expect_query_equal(
    .input$with_columns(y = list(1:2, 3:4)),
    df,
    pl$DataFrame(x = 1:2, y = list(1:2, 3:4))
  )

  expect_query_equal(
    .input$with_columns(y = list(1:2, 3:4), z = list(c("a", "b"), c("c", "d"))),
    df,
    pl$DataFrame(x = 1:2, y = list(1:2, 3:4), z = list(c("a", "b"), c("c", "d")))
  )
})

test_that("with_columns_seq: basic usage", {
  df <- pl$DataFrame(x = 1:2)

  expect_query_equal(
    .input$with_columns_seq(y = 1 + pl$col("x"), z = pl$col("x")^2),
    df,
    pl$DataFrame(x = 1:2, y = c(2, 3), z = c(1, 4))
  )

  # cannot reuse defined variable in same statement
  expect_query_error(
    .input$with_columns_seq(y = 1 + pl$col("x"), z = pl$col("y")^2),
    df,
    "Column(s) not found: y",
    fixed = TRUE
  )

  # chaining multiple with_columns_seq works
  expect_query_equal(
    .input$with_columns_seq(y = 1 + pl$col("x"))$with_columns_seq(z = pl$col("y")^2),
    df,
    pl$DataFrame(x = 1:2, y = c(2, 3), z = c(4, 9))
  )
})

test_that("with_columns_seq can create list variables", {
  df <- pl$DataFrame(x = 1:2)

  expect_query_equal(
    .input$with_columns_seq(y = list(1:2, 3:4)),
    df,
    pl$DataFrame(x = 1:2, y = list(1:2, 3:4))
  )

  expect_query_equal(
    .input$with_columns_seq(y = list(1:2, 3:4), z = list(c("a", "b"), c("c", "d"))),
    df,
    pl$DataFrame(x = 1:2, y = list(1:2, 3:4), z = list(c("a", "b"), c("c", "d")))
  )
})

test_that("bottom_k works", {
  df <- pl$DataFrame(
    a = c("a", "b", "a", "b", "b", "c"),
    b = c(2, 1, 1, 3, 2, 1)
  )
  expect_query_equal(
    .input$bottom_k(4, by = "b"),
    df,
    pl$DataFrame(a = c("b", "a", "c", "a"), b = c(1, 1, 1, 2))
  )
  expect_query_equal(
    .input$bottom_k(4, by = c("a", "b")),
    df,
    pl$DataFrame(a = c("a", "a", "b", "b"), b = c(1, 2, 1, 2))
  )
  expect_query_error(
    .input$bottom_k(4, by = 1),
    df,
    "lengths don't match"
  )
})

test_that("top_k works", {
  df <- pl$DataFrame(
    a = c("a", "b", "a", "b", "b", "c"),
    b = c(2, 1, 1, 3, 2, 1)
  )
  expect_query_equal(
    .input$top_k(4, by = "b"),
    df,
    pl$DataFrame(a = c("b", "a", "b", "b"), b = c(3, 2, 2, 1))
  )
  expect_query_equal(
    .input$top_k(4, by = c("a", "b")),
    df,
    pl$DataFrame(a = c("c", "b", "b", "b"), b = c(1, 3, 2, 1))
  )
  expect_query_error(
    .input$top_k(4, by = 1),
    df,
    "lengths don't match"
  )
})

test_that("join: basic usage", {
  df <- pl$DataFrame(
    foo = 1:3,
    bar = c(6, 7, 8),
    ham = c("a", "b", "c")
  )
  other_df <- pl$DataFrame(
    apple = c("x", "y", "z"),
    ham = c("a", "b", "d")
  )

  # inner default
  expect_query_equal(
    .input$join(.input2, on = "ham"),
    .input = df, .input2 = other_df,
    pl$DataFrame(
      foo = 1:2,
      bar = c(6, 7),
      ham = c("a", "b"),
      apple = c("x", "y")
    )
  )

  # outer
  expect_query_equal(
    .input$join(.input2, on = "ham", how = "full"),
    .input = df, .input2 = other_df,
    pl$DataFrame(
      foo = c(1L, 2L, NA, 3L),
      bar = c(6, 7, NA, 8),
      ham = c("a", "b", NA, "c"),
      apple = c("x", "y", "z", NA),
      ham_right = c("a", "b", "d", NA)
    )
  )

  # error on invalid 'how'
  expect_query_error(
    df$lazy()$join(other_df$lazy(), on = "ham", how = "foobar"),
    "must be one of"
  )
  expect_query_error(
    df$lazy()$join(other_df$lazy(), on = "ham", how = 42),
    "must be a string or character vector"
  )
  # 'other' must be of same class
  expect_query_error(
    df$lazy()$join(other_df, on = "ham"),
    "must be a polars lazy frame"
  )
})

test_that("right join works", {
  a <- pl$DataFrame(a = c(1, 2, 3), b = c(1, 2, 4))
  b <- pl$DataFrame(a = c(1, 3), b = c(1, 3), c = c(1, 3))
  expect_query_equal(
    .input$join(.input2, on = "a", how = "right", coalesce = TRUE),
    .input = a, .input2 = b,
    pl$DataFrame(
      b = c(1, 4),
      a = c(1, 3),
      b_right = c(1, 3),
      c = c(1, 3)
    )
  )
  expect_query_equal(
    .input$join(.input2, on = "a", how = "right", coalesce = TRUE) |>
      names(),
    .input = a, .input2 = b,
    c("a", "b", "a_right", "b_right", "c")
  )
})

test_that("semi and anti join", {
  df_a <- pl$DataFrame(key = 1:3, payload = c("f", "i", NA))
  df_b <- pl$DataFrame(key = c(3L, 4L, 5L, NA))

  expect_query_equal(
    .input$join(.input2, on = "key", how = "anti"),
    .input = df_a, .input2 = df_b,
    pl$DataFrame(key = 1:2, payload = c("f", "i"))
  )
  expect_query_equal(
    .input$join(.input2, on = "key", how = "semi"),
    .input = df_a, .input2 = df_b,
    pl$DataFrame(key = 3L, payload = NA_character_)
  )

  df_a <- pl$DataFrame(a = c(1:3, 1L), b = c("a", "b", "c", "a"), payload = c(10L, 20L, 30L, 40L))
  df_b <- pl$DataFrame(a = c(3L, 3L, 4L, 5L), b = c("c", "c", "d", "e"))

  expect_query_equal(
    .input$join(.input2, on = c("a", "b"), how = "anti"),
    .input = df_a, .input2 = df_b,
    pl$DataFrame(a = c(1:2, 1L), b = c("a", "b", "a"), payload = c(10L, 20L, 40L))
  )
  expect_query_equal(
    .input$join(.input2, on = c("a", "b"), how = "semi"),
    .input = df_a, .input2 = df_b,
    pl$DataFrame(a = 3L, b = "c", payload = 30L)
  )
})

# TODO-REWRITE: panics
# test_that("cross join", {
#   dat <- pl$DataFrame(x = letters[1:3])
#   dat2 <- pl$DataFrame(y = 1:4)

#   expect_query_equal(
#     .input$join(.input2, how = "cross"),
#     .input = dat, .input2 = dat2,
#     pl$DataFrame(
#       x = rep(letters[1:3], each = 4),
#       y = rep(1:4, 3)
#     )
#   )

#   expect_query_error(
#     dat$lazy()$join(.input2$lazy(), how = "cross", on = "foo"),
#     "cross join should not pass join keys"
#   )
#   expect_query_error(
#     dat$lazy()$join(.input2$lazy(), how = "cross", left_on = "foo", right_on = "foo2"),
#     "cross join should not pass join keys"
#   )

#   # one empty dataframe
#   dat_empty <- pl$DataFrame(y = character())
#   expect_query_equal(
#     .input$join(dat_empty, how = "cross"),
#     .input = dat, .input2 = dat2,
#     pl$DataFrame(x = character(), y = character())
#   )
#   expect_query_equal(
#     dat_empty$join(dat, how = "cross"),
#     pl$DataFrame(y = character(), x = character())
#   )

#   # suffix works
#   expect_query_equal(
#     .input$join(.input, how = "cross"),
#     .input = dat,
#     pl$DataFrame(
#       x = rep(letters[1:3], each = 3),
#       x_right = rep(letters[1:3], 3)
#     )
#   )
# })

test_that("argument 'validate' works", {
  df1 <- pl$DataFrame(x = letters[1:5], y = 1:5)
  df2 <- pl$DataFrame(x = c("a", letters[1:4]), y2 = 6:10)

  expect_query_error(
    df1$lazy()$join(df2$lazy(), on = "x", validate = "1:1"),
    "join keys did not fulfill 1:1 validation"
  )
  expect_query_error(
    df1$lazy()$join(df2$lazy(), on = "x", validate = "m:1"),
    "join keys did not fulfill m:1 validation"
  )
  expect_query_error(
    df2$lazy()$join(df1$lazy(), on = "x", validate = "1:m"),
    "join keys did not fulfill 1:m validation"
  )
  expect_query_error(
    df2$lazy()$join(df1$lazy(), on = "x", validate = "foobar"),
    "must be one of"
  )
})

test_that("argument 'join_nulls' works", {
  df1 <- pl$DataFrame(x = c(NA, letters[1:2]), y = 1:3)
  df2 <- pl$DataFrame(x = c(NA, letters[2:3]), y2 = 4:6)

  # discard nulls by default
  expect_query_equal(
    .input$join(.input2, on = "x"),
    .input = df1, .input2 = df2,
    pl$DataFrame(x = "b", y = 3L, y2 = 5L)
  )

  # consider nulls as a valid key
  expect_query_equal(
    .input$join(.input2, on = "x", join_nulls = TRUE),
    .input = df1, .input2 = df2,
    pl$DataFrame(x = c(NA, "b"), y = c(1L, 3L), y2 = c(4L, 5L))
  )

  # several nulls
  df3 <- pl$DataFrame(x = c(NA, letters[2:3], NA), y2 = 4:7)
  expect_query_equal(
    .input$join(.input2, on = "x", join_nulls = TRUE),
    .input = df1, .input2 = df3,
    pl$DataFrame(x = c(NA, "b", NA), y = c(1L, 3L, 1L), y2 = c(4L, 5L, 7L))
  )
})
